// Copyright 2018 The gVisor Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package state

import (
	"bytes"
	"context"
	"fmt"
	"reflect"

	"gvisor.dev/gvisor/pkg/state/wire"
)

// internalCallback is a interface called on object completion.
//
// There are two implementations: objectDecodeState & userCallback.
type internalCallback interface {
	// source returns the dependent object. May be nil.
	source() *objectDecodeState

	// callbackRun executes the callback.
	callbackRun()
}

// userCallback is an implementation of internalCallback.
type userCallback func()

// source implements internalCallback.source.
func (userCallback) source() *objectDecodeState {
	return nil
}

// callbackRun implements internalCallback.callbackRun.
func (uc userCallback) callbackRun() {
	uc()
}

// objectDecodeState represents an object that may be in the process of being
// decoded. Specifically, it represents either a decoded object, or an an
// interest in a future object that will be decoded. When that interest is
// registered (via register), the storage for the object will be created, but
// it will not be decoded until the object is encountered in the stream.
type objectDecodeState struct {
	// id is the id for this object.
	id objectID

	// typ is the id for this typeID. This may be zero if this is not a
	// type-registered structure.
	typ typeID

	// obj is the object. This may or may not be valid yet, depending on
	// whether complete returns true. However, regardless of whether the
	// object is valid, obj contains a final storage location for the
	// object. This is immutable.
	//
	// Note that this must be addressable (obj.Addr() must not panic).
	//
	// The obj passed to the decode methods below will equal this obj only
	// in the case of decoding the top-level object. However, the passed
	// obj may represent individual fields, elements of a slice, etc. that
	// are effectively embedded within the reflect.Value below but with
	// distinct types.
	obj reflect.Value

	// blockedBy is the number of dependencies this object has.
	blockedBy int

	// callbacksInline is inline storage for callbacks.
	callbacksInline [2]internalCallback

	// callbacks is a set of callbacks to execute on load.
	callbacks []internalCallback

	completeEntry
}

// addCallback adds a callback to the objectDecodeState.
func (ods *objectDecodeState) addCallback(ic internalCallback) {
	if ods.callbacks == nil {
		ods.callbacks = ods.callbacksInline[:0]
	}
	ods.callbacks = append(ods.callbacks, ic)
}

// checkComplete checks for completion.
func (ods *objectDecodeState) checkComplete(stats *Stats) bool {
	// Still blocked?
	if ods.blockedBy > 0 {
		return false
	}

	// Trivially complete?
	if ods.callbacks == nil {
		return true
	}

	// Track stats if relevant.
	if ods.typ != 0 {
		stats.start(ods.typ)
		defer stats.done()
	}

	// Fire all callbacks.
	for _, ic := range ods.callbacks {
		ic.callbackRun()
	}

	// Complete now.
	return true
}

// findCycleFor returns when the given object is found in the blocking set.
func (ods *objectDecodeState) findCycleFor(target *objectDecodeState) []*objectDecodeState {
	for _, ic := range ods.callbacks {
		other := ic.source()
		if other != nil && other == target {
			return []*objectDecodeState{target}
		} else if childList := other.findCycleFor(target); childList != nil {
			return append(childList, other)
		}
	}

	// This should not occur.
	Failf("no deadlock found?")
	panic("unreachable")
}

// findCycle finds a dependency cycle.
func (ods *objectDecodeState) findCycle() []*objectDecodeState {
	return append(ods.findCycleFor(ods), ods)
}

// source implements internalCallback.source.
func (ods *objectDecodeState) source() *objectDecodeState {
	return ods
}

// callbackRun implements internalCallback.callbackRun.
func (ods *objectDecodeState) callbackRun() {
	ods.blockedBy--
}

// decodeState is a graph of objects in the process of being decoded.
//
// The decode process involves loading the breadth-first graph generated by
// encode. This graph is read in it's entirety, ensuring that all object
// storage is complete.
//
// As the graph is being serialized, a set of completion callbacks are
// executed. These completion callbacks should form a set of acyclic subgraphs
// over the original one. After decoding is complete, the objects are scanned
// to ensure that all callbacks are executed, otherwise the callback graph was
// not acyclic.
type decodeState struct {
	// ctx is the decode context.
	ctx context.Context

	// r is the input stream.
	r wire.Reader

	// types is the type database.
	types typeDecodeDatabase

	// objectByID is the set of objects in progress.
	objectsByID []*objectDecodeState

	// deferred are objects that have been read, by no interest has been
	// registered yet. These will be decoded once interest in registered.
	deferred map[objectID]wire.Object

	// pending is the set of objects that are not yet complete.
	pending completeList

	// stats tracks time data.
	stats Stats
}

// lookup looks up an object in decodeState or returns nil if no such object
// has been previously registered.
func (ds *decodeState) lookup(id objectID) *objectDecodeState {
	return ds.objectsByID[id-1]
}

// wait registers a dependency on an object.
//
// As a special case, we always allow _useable_ references back to the first
// decoding object because it may have fields that are already decoded. We also
// allow trivial self reference, since they can be handled internally.
func (ds *decodeState) wait(waiter *objectDecodeState, id objectID, callback func()) {
	switch id {
	case waiter.id:
		// Trivial self reference.
		fallthrough
	case 1:
		// Root object; see above.
		if callback != nil {
			callback()
		}
		return
	}

	// Mark as blocked.
	waiter.blockedBy++

	// No nil can be returned here.
	other := ds.lookup(id)
	if callback != nil {
		// Add the additional user callback.
		other.addCallback(userCallback(callback))
	}
	// This callback decrements the blockedBy added above.
	other.addCallback(waiter)
}

// waitObject notes a blocking relationship.
func (ds *decodeState) waitObject(ods *objectDecodeState, encoded wire.Object, callback func()) {
	if rv, ok := encoded.(*wire.Ref); ok && rv.Root != 0 {
		// Refs can encode pointers and maps.
		ds.wait(ods, objectID(rv.Root), callback)
	} else if sv, ok := encoded.(*wire.Slice); ok && sv.Ref.Root != 0 {
		// See decodeObject; we need to wait for the array (if non-nil).
		ds.wait(ods, objectID(sv.Ref.Root), callback)
	} else if iv, ok := encoded.(*wire.Interface); ok {
		// It's an interface (wait recurisvely).
		ds.waitObject(ods, iv.Value, callback)
	} else if callback != nil {
		// Nothing to wait for: execute the callback immediately.
		callback()
	}
}

// walkChild returns a child object from obj, given an accessor path. This is
// the decode-side equivalent to traverse in encode.go.
//
// For the purposes of this function, a child object is either a field within a
// struct or an array element, with one such indirection per element in
// path. The returned value may be an unexported field, so it may not be
// directly assignable. See unsafePointerTo.
func walkChild(path []wire.Dot, obj reflect.Value) reflect.Value {
	// See wire.Ref.Dots. The path here is specified in reverse order.
	for i := len(path) - 1; i >= 0; i-- {
		switch pc := path[i].(type) {
		case *wire.FieldName: // Must be a pointer.
			if obj.Kind() != reflect.Struct {
				Failf("next component in child path is a field name, but the current object is not a struct. Path: %v, current obj: %#v", path, obj)
			}
			obj = obj.FieldByName(string(*pc))
		case wire.Index: // Embedded.
			if obj.Kind() != reflect.Array {
				Failf("next component in child path is an array index, but the current object is not an array. Path: %v, current obj: %#v", path, obj)
			}
			obj = obj.Index(int(pc))
		default:
			panic("unreachable: switch should be exhaustive")
		}
	}
	return obj
}

// register registers a decode with a type.
//
// This type is only used to instantiate a new object if it has not been
// registered previously.
func (ds *decodeState) register(id objectID, typ reflect.Type) *objectDecodeState {
	if len(ds.objectsByID) <= int(id) {
		ds.objectsByID = append(ds.objectsByID, make([]*objectDecodeState, 1+int(id)-len(ds.objectsByID))...)
	}
	ods := ds.objectsByID[id-1]
	if ods != nil {
		return ods
	}

	// Record in the object index.
	if typ.Kind() == reflect.Map {
		ods = &objectDecodeState{
			id:  id,
			obj: reflect.MakeMap(typ),
		}
	} else {
		ods = &objectDecodeState{
			id:  id,
			obj: reflect.New(typ).Elem(),
		}
	}
	ds.objectsByID[id-1] = ods
	ds.pending.PushBack(ods)

	if encoded, ok := ds.deferred[id]; ok {
		// There is a deferred object.
		delete(ds.deferred, id) // Free memory.
		ds.decodeObject(ods, ods.obj, encoded)
	}

	return ods
}

// objectDecoder is for decoding structs.
type objectDecoder struct {
	// ds is decodeState.
	ds *decodeState

	// ods is current object being decoded.
	ods *objectDecodeState

	// reconciledTypeEntry is the reconciled type information.
	rte *reconciledTypeEntry

	// encoded is the encoded object state.
	encoded *wire.Struct
}

// load is helper for the public methods on Source.
func (od *objectDecoder) load(objPtr reflect.Value, wait bool, fn func()) {
	v, ok := od.encoded.Next()
	if !ok {
		// This means that the Load does not match the TypeInfo.
		Failf("unexpected load call on %#v: %#v", objPtr.Interface(), od.encoded)
	}
	od.ds.decodeObject(od.ods, objPtr.Elem(), v)
	if wait {
		// Mark this individual object a blocker.
		od.ds.waitObject(od.ods, v, fn)
	}
}

// aterLoad implements Source.AfterLoad.
func (od *objectDecoder) afterLoad(fn func()) {
	// Queue the local callback; this will execute when all of the above
	// data dependencies have been cleared.
	od.ods.addCallback(userCallback(fn))
}

// decodeStruct decodes a struct value.
func (ds *decodeState) decodeStruct(ods *objectDecodeState, obj reflect.Value, encoded *wire.Struct) {
	// Lookup the object type.
	sl, rte := ds.types.Lookup(typeID(encoded.TypeID), obj.Addr())
	if rte == nil {
		if _, ok := encoded.Next(); !ok && obj.NumField() == 0 && encoded.TypeID == 0 {
			// Allow anonymous empty structs, but only if the
			// encoded object has no fields and no TypeID.
			return
		}
		// Propagate an error.
		Failf("unregistered type %s", obj.Type())
	}

	// Save the type information.
	ods.typ = typeID(encoded.TypeID)

	// Invoke the loader.
	od := objectDecoder{
		ds:      ds,
		ods:     ods,
		rte:     rte,
		encoded: encoded,
	}
	ds.stats.start(ods.typ)
	defer ds.stats.done()
	sl.StateLoad(Source{internal: od})

	// Sanity check the fields.
	if _, ok := od.encoded.Next(); ok {
		Failf("unexpected left over fields on %#v: %#v", obj.Interface(), od.encoded)
	}
}

// decodeMap decodes a map value.
func (ds *decodeState) decodeMap(ods *objectDecodeState, obj reflect.Value, encoded *wire.Map) {
	if obj.IsNil() {
		// Need to ensure the map is created.
		obj.Set(reflect.MakeMap(obj.Type()))
	}
	for i := 0; i < len(encoded.Keys); i++ {
		// Decode the objects.
		kv := reflect.New(obj.Type().Key()).Elem()
		vv := reflect.New(obj.Type().Elem()).Elem()
		ds.decodeObject(ods, kv, encoded.Keys[i])
		ds.decodeObject(ods, vv, encoded.Values[i])
		ds.waitObject(ods, encoded.Keys[i], nil)
		ds.waitObject(ods, encoded.Values[i], nil)

		// Set in the map.
		obj.SetMapIndex(kv, vv)
	}
}

// decodeArray decodes an array value.
func (ds *decodeState) decodeArray(ods *objectDecodeState, obj reflect.Value, encoded *wire.Array) {
	if len(encoded.Contents) != obj.Len() {
		Failf("mismatching array length expect=%d, actual=%d", obj.Len(), len(encoded.Contents))
	}
	// Decode the contents into the array.
	for i := 0; i < len(encoded.Contents); i++ {
		ds.decodeObject(ods, obj.Index(i), encoded.Contents[i])
		ds.waitObject(ods, encoded.Contents[i], nil)
	}
}

// decodeInterface decodes an interface value.
func (ds *decodeState) decodeInterface(ods *objectDecodeState, obj reflect.Value, encoded *wire.Interface) {
	// Get the dispatchable type.
	name, ok := ds.types.LookupName(typeID(encoded.TypeID))
	if !ok {
		Failf("no known type of ID %d", encoded.TypeID)
	}
	typ, ok := lookupType(name)
	if !ok {
		Failf("no known type %s", name)
	}
	if obj.Kind() != reflect.Map {
		// Set the obj to be the given typed value; this actually sets
		// obj to be a non-zero value -- namely, it inserts type
		// information. There's no need to do this for maps.
		obj.Set(reflect.Zero(typ))
	}

	// Decode the dereferenced element; there is no need to wait here, as
	// the interface object shares the current object state.
	ds.decodeObject(ods, obj, encoded.Value)
}

// decodeObject decodes a object value.
func (ds *decodeState) decodeObject(ods *objectDecodeState, obj reflect.Value, encoded wire.Object) {
	switch x := encoded.(type) {
	case wire.Nil: // Fast path: first.
		// We leave obj alone here. That's because if obj represents an
		// interface, it may have been imbued with type information in
		// decodeInterface, and we don't want to destroy that information.
	case *wire.Ref:
		// Resolve the pointer itself, even though the object may not
		// be decoded yet. You need to use wait() in order to ensure
		// that is the case. See wait above.
		id := objectID(x.Root)

		// Nil pointers may be encoded in a "forceValue" context. For
		// those we just leave it alone as the value will already be
		// correct.
		if id == 0 {
			return
		}

		// Decoding the interface should have imparted type information, so from
		// this point it's safe to resolve and use this dynamic information for
		// actually creating the object in register.
		dyntyp := reflect.TypeOf(obj.Interface())
		if dyntyp.Kind() == reflect.Map {
			obj.Set(ds.register(id, dyntyp).obj)
			return
		}

		// A RefValue may either refer to an object directly, or a
		// child element of the object (with potential intermediate
		// types). When referring to a child element, x.Dots will be
		// non-empty. In both cases, we can call traverseChild to
		// obtain a reference to the appropriate object.
		if dyntyp.Elem().Kind() == reflect.Map {
			obj.Set(walkChild(x.Dots, ds.register(id, dyntyp).obj))
			return
		}

		// Regular object pointer.
		obj.Set(unsafePointerTo(walkChild(x.Dots, ds.register(id, dyntyp.Elem()).obj)))
	case wire.Bool:
		obj.SetBool(bool(x))
	case wire.Int:
		obj.SetInt(int64(x))
		if obj.Int() != int64(x) {
			Failf("signed integer truncated in %v for %s", encoded, obj.Type())
		}
	case wire.Uint:
		obj.SetUint(uint64(x))
		if obj.Uint() != uint64(x) {
			Failf("unsigned integer truncated in %v for %s", encoded, obj.Type())
		}
	case wire.Float:
		obj.SetFloat(float64(x))
		if obj.Float() != float64(x) {
			Failf("floating point number truncated in %v for %s", encoded, obj.Type())
		}
	case *wire.Complex:
		obj.SetComplex(complex128(*x))
		if obj.Complex() != complex128(*x) {
			Failf("complex number truncated in %v for %s", encoded, obj.Type())
		}
	case *wire.String:
		obj.SetString(string(*x))
	case *wire.Slice:
		// It's okay to slice the array here, since the contents will
		// still be provided later on. Note that nil pointers may still
		// be encoded in a "forceValue" context.
		id := objectID(x.Ref.Root)
		if id != 0 {
			v := reflect.ArrayOf(int(x.Capacity), obj.Type().Elem()) // The object type.
			obj.Set(walkChild(x.Ref.Dots, ds.register(id, v).obj).Slice3(0, int(x.Length), int(x.Capacity)))
		}
	case *wire.Array:
		ds.decodeArray(ods, obj, x)
	case *wire.Struct:
		ds.decodeStruct(ods, obj, x)
	case *wire.Map:
		ds.decodeMap(ods, obj, x)
	case *wire.Interface:
		ds.decodeInterface(ods, obj, x)
	default:
		// Shoud not happen, not propagated as an error.
		Failf("unknown object %#v for %s", encoded, obj.Type())
	}
}

// Load deserializes the object graph rooted at obj.
//
// This function may panic and should be run in safely().
func (ds *decodeState) Load(obj reflect.Value) {
	ds.stats.init()
	defer ds.stats.fini(func(id typeID) string {
		name, _ := ds.types.LookupName(id)
		return name
	})

	// Create the root object.
	ds.objectsByID = append(ds.objectsByID, &objectDecodeState{
		id:  1,
		obj: obj,
	})

	// Read the number of objects.
	lastID, object, err := ReadHeader(ds.r)
	if err != nil {
		Failf("header error: %v", err)
	}
	if !object {
		Failf("object missing")
	}

	// Decode all objects.
	var (
		encoded wire.Object
		ods     *objectDecodeState
	)
	if err := safely(func() {
		// Decode all objects in the stream.
		//
		// Note that the structure of this decoding loop should match
		// the raw decoding loop in printer.go.
		var id = objectID(1)
		for id <= objectID(lastID) {
			// Unmarshal the object.
			encoded = wire.Load(ds.r)

			// Is this a type object? Handle inline.
			if t, ok := encoded.(*wire.Type); ok {
				ds.types.Register(wireToTypeInfo(t))
				encoded = nil
				continue
			}

			// Actually resolve the object.
			ods = ds.lookup(id)
			if ods != nil {
				// Decode the object.
				ds.decodeObject(ods, ods.obj, encoded)
			} else {
				// If an object hasn't had interest registered
				// previously, we deferred decoding until
				// interest is registered.
				ds.deferred[id] = encoded
			}

			// For error handling.
			ods = nil
			encoded = nil
			id++
		}
	}); err != nil {
		// Include as much information as we can, taking into account
		// the possible state transitions above.
		if ods != nil {
			maybeFailf(err, "error decoding %#v from %#v: %v", ods.obj.Interface(), encoded, err)
		} else if encoded != nil {
			maybeFailf(err, "lookup error decoding %#v: %v", encoded, err)
		} else {
			maybeFailf(err, "general decoding error: %v", err)
		}
	}

	// Check if we have any deferred objects.
	for id, encoded := range ds.deferred {
		// Shoud never happen, the graph was bogus.
		Failf("still have deferred objects: one is ID %d, %#v", id, encoded)
	}

	// Scan and fire all callbacks. We iterate over the list of incomplete
	// objects until all have been finished. We stop iterating if no
	// objects become complete (there is a dependency cycle).
	//
	// Note that we iterate backwards here, because there will be a strong
	// tendendcy for blocking relationships to go from earlier objects to
	// later (deeper) objects in the graph. This will reduce the number of
	// iterations required to finish all objects.
	if err := safely(func() {
		for ds.pending.Back() != nil {
			thisCycle := 0
			for ods = ds.pending.Back(); ods != nil; {
				if ods.checkComplete(&ds.stats) {
					oldODS := ods
					ods = ods.Prev()
					ds.pending.Remove(oldODS)
					thisCycle++
				} else {
					ods = ods.Prev()
				}
			}
			if thisCycle == 0 {
				break
			}
		}
	}); err != nil {
		// N.B. Unlike other errors in this package, this error is
		// specifically *wrapped*. That means that the user can pass an
		// error via panic that will be propagated here, and this error
		// can be unwrapped appropriately.
		maybeFailf(err, "error executing callbacks for %#v: %w", ods.obj.Interface(), err)
	}

	// Check if we have any remaining dependency cycles. If there are any
	// objects left in the pending list, then it must be due to a cycle.
	if ods := ds.pending.Front(); ods != nil {
		// This must be the result of a dependency cycle.
		cycle := ods.findCycle()
		var buf bytes.Buffer
		buf.WriteString("dependency cycle: {")
		for i, cycleOS := range cycle {
			if i > 0 {
				buf.WriteString(" => ")
			}
			fmt.Fprintf(&buf, "%s", cycleOS.obj.Type())
		}
		buf.WriteString("}")
		Failf("incomplete graph: %s", string(buf.Bytes()))
	}
}

// ReadHeader reads an object header.
//
// Each object written to the statefile is prefixed with a header. See
// WriteHeader for more information; these functions are exported to allow
// non-state writes to the file to play nice with debugging tools.
func ReadHeader(r wire.Reader) (length uint64, object bool, err error) {
	// Read the header.
	err = safely(func() {
		length = uint64(wire.LoadUint(r))
	})
	if err != nil {
		// On the header, pass raw I/O errors.
		if sErr, ok := err.(*ErrState); ok {
			return 0, false, sErr.Unwrap()
		}
	}

	// Decode whether the object is valid.
	object = length&0x1 != 0
	length = length >> 1
	return
}
